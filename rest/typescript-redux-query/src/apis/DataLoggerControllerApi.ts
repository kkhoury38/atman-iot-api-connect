// tslint:disable
/**
 * Atman IoT
 * Atman IoT Server
 *
 * The version of the OpenAPI document: 0.2.3
 * Contact: k.khoury@k-ren.gr
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';

import {
    DataLogger,
    DataLoggerFromJSON,
    DataLoggerToJSON,
    DataLoggerExcludingIdAuthTokenConfigUserId,
    DataLoggerExcludingIdAuthTokenConfigUserIdFromJSON,
    DataLoggerExcludingIdAuthTokenConfigUserIdToJSON,
    RequestDataLoggerSetupCsv2ExcludingFileFormat,
    RequestDataLoggerSetupCsv2ExcludingFileFormatFromJSON,
    RequestDataLoggerSetupCsv2ExcludingFileFormatToJSON,
    RequestDataLoggerSetupXml2ExcludingFileFormat,
    RequestDataLoggerSetupXml2ExcludingFileFormatFromJSON,
    RequestDataLoggerSetupXml2ExcludingFileFormatToJSON,
    ResponseDataLoggerSetupStep2,
    ResponseDataLoggerSetupStep2FromJSON,
    ResponseDataLoggerSetupStep2ToJSON,
} from '../models';

export interface DataLoggerControllerCreateRequest {
    dataLoggerExcludingIdAuthTokenConfigUserId?: DataLoggerExcludingIdAuthTokenConfigUserId;
}

export interface DataLoggerControllerDeleteByIdRequest {
    id: number;
}

export interface DataLoggerControllerSetupFromFtp1Request {
    id: number;
    dataLoggerToken: string;
}

export interface DataLoggerControllerSetupFromFtp3Request {
    id: number;
    responseDataLoggerSetupStep2?: ResponseDataLoggerSetupStep2;
}

export interface DataLoggerControllerSetupFromFtpCsv2Request {
    id: number;
    requestDataLoggerSetupCsv2ExcludingFileFormat?: RequestDataLoggerSetupCsv2ExcludingFileFormat;
}

export interface DataLoggerControllerSetupFromFtpXml2Request {
    id: number;
    requestDataLoggerSetupXml2ExcludingFileFormat?: RequestDataLoggerSetupXml2ExcludingFileFormat;
}

export interface DataLoggerControllerUploadDataFromCsvRequest {
    id: number;
    dataLoggerToken: string;
}

export interface DataLoggerControllerUploadDataFromXmlRequest {
    id: number;
    dataLoggerToken: string;
}


/**
 * Used for creating a new <b>DataLogger</b> by and authorized <b>User</b>, identified by the provided <i>token</i>. <br><br><i><b>References:</b> <a href=\"/documentation.html#atman-iot-usercontroller\" target=\"_blank\">UserController</a>, <a href=\"/documentation.html#tocsdatalogger\" target=\"_blank\">DataLoggerModel</a></i>
 */
function dataLoggerControllerCreateRaw<T>(requestParameters: DataLoggerControllerCreateRequest, requestConfig: runtime.TypedQueryConfig<T, DataLogger> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `/data-logger`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || DataLoggerExcludingIdAuthTokenConfigUserIdToJSON(requestParameters.dataLoggerExcludingIdAuthTokenConfigUserId),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DataLoggerFromJSON(body), text);
    }

    return config;
}

/**
* Used for creating a new <b>DataLogger</b> by and authorized <b>User</b>, identified by the provided <i>token</i>. <br><br><i><b>References:</b> <a href=\"/documentation.html#atman-iot-usercontroller\" target=\"_blank\">UserController</a>, <a href=\"/documentation.html#tocsdatalogger\" target=\"_blank\">DataLoggerModel</a></i>
*/
export function dataLoggerControllerCreate<T>(requestParameters: DataLoggerControllerCreateRequest, requestConfig?: runtime.TypedQueryConfig<T, DataLogger>): QueryConfig<T> {
    return dataLoggerControllerCreateRaw(requestParameters, requestConfig);
}

/**
 * Deletes a<b> DataLogger</b> identified by <i>id</i>, owned by a <b>User</b> identified by the provided <i>token.</i><br><br><i><b>References:</b> <a href=\"/documentation.html#atman-iot-usercontroller\" target=\"_blank\">UserController</a>, <a href=\"/documentation.html#tocsdatalogger\" target=\"_blank\">DataLoggerModel</a></i>
 */
function dataLoggerControllerDeleteByIdRaw<T>(requestParameters: DataLoggerControllerDeleteByIdRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling dataLoggerControllerDeleteById.');
    }

    let queryParameters = null;


    const headerParameters = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `/data-logger/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Deletes a<b> DataLogger</b> identified by <i>id</i>, owned by a <b>User</b> identified by the provided <i>token.</i><br><br><i><b>References:</b> <a href=\"/documentation.html#atman-iot-usercontroller\" target=\"_blank\">UserController</a>, <a href=\"/documentation.html#tocsdatalogger\" target=\"_blank\">DataLoggerModel</a></i>
*/
export function dataLoggerControllerDeleteById<T>(requestParameters: DataLoggerControllerDeleteByIdRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return dataLoggerControllerDeleteByIdRaw(requestParameters, requestConfig);
}

/**
 * Returns an array of <b>DataLoggers</b> owned by a <b>User</b> identified by the provided <i>token.</i><br><br><i><b>References:</b> <a href=\"/documentation.html#atman-iot-usercontroller\" target=\"_blank\">UserController</a>, <a href=\"/documentation.html#tocsdatalogger\" target=\"_blank\">DataLoggerModel</a></i>
 */
function dataLoggerControllerFindRaw<T>( requestConfig: runtime.TypedQueryConfig<T, Array<DataLogger>> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `/data-loggers`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(DataLoggerFromJSON), text);
    }

    return config;
}

/**
* Returns an array of <b>DataLoggers</b> owned by a <b>User</b> identified by the provided <i>token.</i><br><br><i><b>References:</b> <a href=\"/documentation.html#atman-iot-usercontroller\" target=\"_blank\">UserController</a>, <a href=\"/documentation.html#tocsdatalogger\" target=\"_blank\">DataLoggerModel</a></i>
*/
export function dataLoggerControllerFind<T>( requestConfig?: runtime.TypedQueryConfig<T, Array<DataLogger>>): QueryConfig<T> {
    return dataLoggerControllerFindRaw( requestConfig);
}

/**
 * Step 1 of setup process of <b>DataLoggers</b> sending data via FTP. It is used for sending a sample uncompressed <i>file</i> containing raw data, as it was generated by the <b>DataLogger</b> (hardware) identified by <i>dataLoggerToken</i>.<br><br><i><b>References:</b> <a href=\"/documentation.html#tocsdatalogger\" target=\"_blank\">DataLoggerModel</a></i>
 */
function dataLoggerControllerSetupFromFtp1Raw<T>(requestParameters: DataLoggerControllerSetupFromFtp1Request, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling dataLoggerControllerSetupFromFtp1.');
    }

    if (requestParameters.dataLoggerToken === null || requestParameters.dataLoggerToken === undefined) {
        throw new runtime.RequiredError('dataLoggerToken','Required parameter requestParameters.dataLoggerToken was null or undefined when calling dataLoggerControllerSetupFromFtp1.');
    }

    let queryParameters = null;


    const headerParameters = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `/data-logger/setup-ftp/step1/{id}/{dataLoggerToken}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"dataLoggerToken"}}`, encodeURIComponent(String(requestParameters.dataLoggerToken))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Step 1 of setup process of <b>DataLoggers</b> sending data via FTP. It is used for sending a sample uncompressed <i>file</i> containing raw data, as it was generated by the <b>DataLogger</b> (hardware) identified by <i>dataLoggerToken</i>.<br><br><i><b>References:</b> <a href=\"/documentation.html#tocsdatalogger\" target=\"_blank\">DataLoggerModel</a></i>
*/
export function dataLoggerControllerSetupFromFtp1<T>(requestParameters: DataLoggerControllerSetupFromFtp1Request, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return dataLoggerControllerSetupFromFtp1Raw(requestParameters, requestConfig);
}

/**
 * Step 3 of setup process of <b>DataLoggers</b> sending data via FTP. It is used for initiating <b>DeviceTypes</b>, <b>ChannelTypes</b> and <b>Devices</b>. Accepts as input the output of Step 2. Make sure that the <i>manufacturer</i> property is added.<br><br><i><b>References:</b> <a href=\"/documentation.html#atman-iot-devicecontroller\" target=\"_blank\">DeviceController</a>, <a href=\"/documentation.html#atman-iot-devicetypecontroller\" target=\"_blank\">DeviceTypeController</a>, <a href=\"/documentation.html#atman-iot-devicetypechanneltypecontroller\" target=\"_blank\">DeviceTypeChannelTypeController</a>, <a href=\"/documentation.html#atman-iot-usercontroller\" target=\"_blank\">UserController</a>, <a href=\"/documentation.html#tocsdatalogger\" target=\"_blank\">DataLoggerModel</a></i>
 */
function dataLoggerControllerSetupFromFtp3Raw<T>(requestParameters: DataLoggerControllerSetupFromFtp3Request, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling dataLoggerControllerSetupFromFtp3.');
    }

    let queryParameters = null;


    const headerParameters = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `/data-logger/setup-ftp/step3/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || ResponseDataLoggerSetupStep2ToJSON(requestParameters.responseDataLoggerSetupStep2),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Step 3 of setup process of <b>DataLoggers</b> sending data via FTP. It is used for initiating <b>DeviceTypes</b>, <b>ChannelTypes</b> and <b>Devices</b>. Accepts as input the output of Step 2. Make sure that the <i>manufacturer</i> property is added.<br><br><i><b>References:</b> <a href=\"/documentation.html#atman-iot-devicecontroller\" target=\"_blank\">DeviceController</a>, <a href=\"/documentation.html#atman-iot-devicetypecontroller\" target=\"_blank\">DeviceTypeController</a>, <a href=\"/documentation.html#atman-iot-devicetypechanneltypecontroller\" target=\"_blank\">DeviceTypeChannelTypeController</a>, <a href=\"/documentation.html#atman-iot-usercontroller\" target=\"_blank\">UserController</a>, <a href=\"/documentation.html#tocsdatalogger\" target=\"_blank\">DataLoggerModel</a></i>
*/
export function dataLoggerControllerSetupFromFtp3<T>(requestParameters: DataLoggerControllerSetupFromFtp3Request, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return dataLoggerControllerSetupFromFtp3Raw(requestParameters, requestConfig);
}

/**
 * Step 2 of setup process of <b>DataLoggers</b> sending CSV data via FTP. It is used for mapping properties of the sent <i>file</i> to properties of models in the system. <b>DataLogger</b> to be setup, is identified by <i>id</i> and <b>User</b> performing operation is identified by <i>token</i>. Endpoint response represents the results of the mapping (required in Step 3). If it is satisfactory, it is saved by setting the property <i>confirm</i> to <i>true</i>.<br><br><i><b>References:</b> <a href=\"/documentation.html#atman-iot-usercontroller\" target=\"_blank\">UserController</a>, <a href=\"/documentation.html#tocsdatalogger\" target=\"_blank\">DataLoggerModel</a></i>
 */
function dataLoggerControllerSetupFromFtpCsv2Raw<T>(requestParameters: DataLoggerControllerSetupFromFtpCsv2Request, requestConfig: runtime.TypedQueryConfig<T, ResponseDataLoggerSetupStep2> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling dataLoggerControllerSetupFromFtpCsv2.');
    }

    let queryParameters = null;


    const headerParameters = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `/data-logger/setup-ftp/step2/csv/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || RequestDataLoggerSetupCsv2ExcludingFileFormatToJSON(requestParameters.requestDataLoggerSetupCsv2ExcludingFileFormat),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ResponseDataLoggerSetupStep2FromJSON(body), text);
    }

    return config;
}

/**
* Step 2 of setup process of <b>DataLoggers</b> sending CSV data via FTP. It is used for mapping properties of the sent <i>file</i> to properties of models in the system. <b>DataLogger</b> to be setup, is identified by <i>id</i> and <b>User</b> performing operation is identified by <i>token</i>. Endpoint response represents the results of the mapping (required in Step 3). If it is satisfactory, it is saved by setting the property <i>confirm</i> to <i>true</i>.<br><br><i><b>References:</b> <a href=\"/documentation.html#atman-iot-usercontroller\" target=\"_blank\">UserController</a>, <a href=\"/documentation.html#tocsdatalogger\" target=\"_blank\">DataLoggerModel</a></i>
*/
export function dataLoggerControllerSetupFromFtpCsv2<T>(requestParameters: DataLoggerControllerSetupFromFtpCsv2Request, requestConfig?: runtime.TypedQueryConfig<T, ResponseDataLoggerSetupStep2>): QueryConfig<T> {
    return dataLoggerControllerSetupFromFtpCsv2Raw(requestParameters, requestConfig);
}

/**
 * Step 2 of setup process of <b>DataLoggers</b> sending XML data via FTP. It is used for mapping properties of the sent <i>file</i> to properties of models in the system. <b>DataLogger</b> to be setup, is identified by <i>id</i> and <b>User</b> performing operation is identified by <i>token</i>. Endpoint response represents the results of the mapping (required in Step 3). If it is satisfactory, it is saved by setting the property <i>confirm</i> to <i>true</i>.<br><br><i><b>References:</b> <a href=\"/documentation.html#atman-iot-usercontroller\" target=\"_blank\">UserController</a>, <a href=\"/documentation.html#tocsdatalogger\" target=\"_blank\">DataLoggerModel</a></i>
 */
function dataLoggerControllerSetupFromFtpXml2Raw<T>(requestParameters: DataLoggerControllerSetupFromFtpXml2Request, requestConfig: runtime.TypedQueryConfig<T, ResponseDataLoggerSetupStep2> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling dataLoggerControllerSetupFromFtpXml2.');
    }

    let queryParameters = null;


    const headerParameters = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `/data-logger/setup-ftp/step2/xml/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || RequestDataLoggerSetupXml2ExcludingFileFormatToJSON(requestParameters.requestDataLoggerSetupXml2ExcludingFileFormat),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ResponseDataLoggerSetupStep2FromJSON(body), text);
    }

    return config;
}

/**
* Step 2 of setup process of <b>DataLoggers</b> sending XML data via FTP. It is used for mapping properties of the sent <i>file</i> to properties of models in the system. <b>DataLogger</b> to be setup, is identified by <i>id</i> and <b>User</b> performing operation is identified by <i>token</i>. Endpoint response represents the results of the mapping (required in Step 3). If it is satisfactory, it is saved by setting the property <i>confirm</i> to <i>true</i>.<br><br><i><b>References:</b> <a href=\"/documentation.html#atman-iot-usercontroller\" target=\"_blank\">UserController</a>, <a href=\"/documentation.html#tocsdatalogger\" target=\"_blank\">DataLoggerModel</a></i>
*/
export function dataLoggerControllerSetupFromFtpXml2<T>(requestParameters: DataLoggerControllerSetupFromFtpXml2Request, requestConfig?: runtime.TypedQueryConfig<T, ResponseDataLoggerSetupStep2>): QueryConfig<T> {
    return dataLoggerControllerSetupFromFtpXml2Raw(requestParameters, requestConfig);
}

/**
 * Used for receiving data, sent in CSV format by a <b>DataLogger</b> identified by <i>id</i> and <i>dataLoggerToken</i>. If the <b>DataLogger</b> is sending data via FTP, endpoint is called internally.<br><br><i><b>References:</b> <a href=\"/documentation.html#tocsdatalogger\" target=\"_blank\">DataLoggerModel</a></i>
 */
function dataLoggerControllerUploadDataFromCsvRaw<T>(requestParameters: DataLoggerControllerUploadDataFromCsvRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling dataLoggerControllerUploadDataFromCsv.');
    }

    if (requestParameters.dataLoggerToken === null || requestParameters.dataLoggerToken === undefined) {
        throw new runtime.RequiredError('dataLoggerToken','Required parameter requestParameters.dataLoggerToken was null or undefined when calling dataLoggerControllerUploadDataFromCsv.');
    }

    let queryParameters = null;


    const headerParameters = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `/data-logger/data-from-csv/{id}/{dataLoggerToken}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"dataLoggerToken"}}`, encodeURIComponent(String(requestParameters.dataLoggerToken))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Used for receiving data, sent in CSV format by a <b>DataLogger</b> identified by <i>id</i> and <i>dataLoggerToken</i>. If the <b>DataLogger</b> is sending data via FTP, endpoint is called internally.<br><br><i><b>References:</b> <a href=\"/documentation.html#tocsdatalogger\" target=\"_blank\">DataLoggerModel</a></i>
*/
export function dataLoggerControllerUploadDataFromCsv<T>(requestParameters: DataLoggerControllerUploadDataFromCsvRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return dataLoggerControllerUploadDataFromCsvRaw(requestParameters, requestConfig);
}

/**
 * Used for receiving data, sent in XML format by a <b>DataLogger</b> identified by <i>id</i> and <i>dataLoggerToken</i>. If the <b>DataLogger</b> is sending data via FTP, endpoint is called internally.<br><br><i><b>References:</b> <a href=\"/documentation.html#tocsdatalogger\" target=\"_blank\">DataLoggerModel</a></i>
 */
function dataLoggerControllerUploadDataFromXmlRaw<T>(requestParameters: DataLoggerControllerUploadDataFromXmlRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling dataLoggerControllerUploadDataFromXml.');
    }

    if (requestParameters.dataLoggerToken === null || requestParameters.dataLoggerToken === undefined) {
        throw new runtime.RequiredError('dataLoggerToken','Required parameter requestParameters.dataLoggerToken was null or undefined when calling dataLoggerControllerUploadDataFromXml.');
    }

    let queryParameters = null;


    const headerParameters = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `/data-logger/data-from-xml/{id}/{dataLoggerToken}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"dataLoggerToken"}}`, encodeURIComponent(String(requestParameters.dataLoggerToken))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Used for receiving data, sent in XML format by a <b>DataLogger</b> identified by <i>id</i> and <i>dataLoggerToken</i>. If the <b>DataLogger</b> is sending data via FTP, endpoint is called internally.<br><br><i><b>References:</b> <a href=\"/documentation.html#tocsdatalogger\" target=\"_blank\">DataLoggerModel</a></i>
*/
export function dataLoggerControllerUploadDataFromXml<T>(requestParameters: DataLoggerControllerUploadDataFromXmlRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return dataLoggerControllerUploadDataFromXmlRaw(requestParameters, requestConfig);
}

